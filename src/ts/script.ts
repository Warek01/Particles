let styleIsAdded: boolean = false;

class ParticlesController<Elem extends HTMLElement> {
  private initialOverflow!: string | null;
  private intervalId!: any | null;
  private callback!: (() => void) | null;

  public density: Density | null;
  public attachedElement: Elem | null;
  public transitionDuration: number | null;
  public particleSize: number | null;
  public angle: number;
  public active: boolean | null;

  constructor({
    element,
    type,
    fallDuration: duration,
    density,
    size,
    hideParentOverflow: overflow,
    active,
    angle,
  }: ControllerSetup<Elem>) {
    this.attachedElement = element!;
    this.transitionDuration = duration!;
    this.density = density!;
    this.particleSize = size!;
    this.initialOverflow = getComputedStyle(this.attachedElement).overflow;
    this.angle = angle!;

    this.active = active!;
    if (!active) this.disable();
    else this.setInterval();

    this.attachedElement.dataset.type = type!;

    if (overflow) this.attachedElement.style.overflow = "hidden";
  }

  get type(): ParticlesType {
    return <ParticlesType>this.attachedElement!.dataset.type;
  }

  set type(type: ParticlesType) {
    console.assert(type !== null && type !== this.type);

    this.attachedElement!.dataset.type = type;
  }

  private get width(): number {
    return this.attachedElement!.clientWidth;
  }

  private get height(): number {
    return this.attachedElement!.clientHeight;
  }

  private get startY(): number {
    return -this.particleSize!;
  }

  private get endY(): number {
    return this.height + this.particleSize!;
  }

  private get startX(): number {
    return +(Math.random() * this.width);
  }

  private get endX(): number {
    return this.startX;
  }

  private setInterval(): void {
    let interval: number;
    switch (this.density) {
      case "low":
        interval = 400;
        break;
      case "normal":
        interval = 200;
        break;
      case "dense":
        interval = 120;
        break;
      case "storm":
        interval = 20;
        break;
      default:
        interval = 200;
    }

    const factory = () => {
      if (!this.active) return;

      const particle = document.createElement("div");
      const range = this.height * Math.tan(degToRad(this.angle));
      const offset = Math.abs(range);

      let startX = Math.ceil(Math.random() * this.width);
      
      if (this.angle > 0 && this.angle < 90) {
        startX = Math.floor(Math.random() * (this.width - -offset) + -offset);
      } else if (this.angle < 0 && this.angle > -90) {
        startX = Math.floor(Math.random() * (this.width + offset));
      }

      const endX = this.angle ? range + startX : startX;

      particle.ontransitionend = () => particle.remove();
      particle.classList.add("particle", this.type);
      particle.style.cssText = `
        width: ${this.particleSize}px;
        height: ${this.particleSize}px;
        top: ${this.startY}px;
        left: ${startX}px;
        transition: all ${this.transitionDuration}ms linear;
      `;

      this.attachedElement!.append(particle);

      particle.style.top = this.endY + "px";
      particle.style.left = endX + "px";
    };
    this.intervalId = setInterval(factory, interval);
    this.callback = factory;
  }

  public disable(force = false): Elem {
    if (!this.active) return this.attachedElement!;

    this.active = false;
    clearInterval(this.intervalId);
    this.intervalId = null;

    this.attachedElement!.style.overflow = this.initialOverflow!;

    if (force)
      document.querySelectorAll(".particle").forEach((el) => {
        el.remove();
      });

    return this.attachedElement!;
  }

  public enable(): Elem {
    if (this.active) this.attachedElement;

    this.active = true;
    this.setInterval();

    return this.attachedElement!;
  }

  public destroy(): Elem {
    const elem = this.attachedElement!;
    this.attachedElement!.dataset.type = "";

    this.disable(true);
    this.callback = null;
    this.attachedElement = null;
    this.particleSize = null;
    this.initialOverflow = null;
    this.transitionDuration = null;
    this.active = false;
    this.density = null;

    return elem;
  }
}

export default function addParticles<Elem extends HTMLElement>({
  element,
  type = "rain",
  fallDuration: duration = 3000,
  density = "normal",
  size = 5,
  hideParentOverflow = false,
  active = true,
  angle = 0,
}: ControllerSetup<Elem>): ParticlesController<Elem> {
  if (!styleIsAdded) {
    const style = document.createElement("style");
    style.appendChild(
      document.createTextNode(`
        /* Generated by script */
        .particle { position: absolute; display: block; z-index: -1; }
        .particle.rain { background-color: #3498db; }
        .particle.snow { background-color: #dff9fb; }
    `)
    );
    document.body.append(style);
  }

  return new ParticlesController<Elem>({
    element,
    fallDuration: duration,
    type: type,
    density,
    size,
    hideParentOverflow,
    active,
    angle,
  });
}

/** Returs given value in radians */
function degToRad(num: number) {
  return num * (Math.PI / 180);
}

type ParticlesType = "rain" | "snow";
type Density = "low" | "normal" | "dense" | "storm";

interface ControllerSetup<Elem extends HTMLElement> {
  /** Element which particles will be applied on */
  element: Elem;
  /** Type of particles */
  type?: ParticlesType;
  /** Particle fall duration (ms)
   * @default 3000
   */
  fallDuration?: number;
  /** Particle generation density
   * @default "normal"
   */
  density?: Density;
  /** Particle size (px)
   * @default 5
   */
  size?: number;
  /** Set parent element's css "overflow: hidden"
   * @default false
   */
  hideParentOverflow?: boolean;
  /** If particle generation is active
   * @default true
   */
  active?: boolean;
  /** Particles fall angle
   * @default 0
   */
  angle?: number;
}
